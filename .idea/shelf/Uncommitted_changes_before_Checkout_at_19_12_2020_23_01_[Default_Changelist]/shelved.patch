Index: Yolopoly/src/main/java/com/yolopoly/managers/InGameManager.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.yolopoly.managers;\r\n\r\nimport com.yolopoly.enumerations.*;\r\nimport com.yolopoly.models.bases.*;\r\nimport com.yolopoly.models.cards.PlaceCard;\r\nimport com.yolopoly.models.cards.PropertyCard;\r\nimport com.yolopoly.storage.Constants;\r\nimport com.yolopoly.storage.StorageUtil;\r\n\r\nimport java.io.IOException;\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\n\r\n\r\npublic class InGameManager {\r\n\r\n    // Constants\r\n    private final static int JAIL_TURN_COUNT = 3;\r\n    private final static int AUCTION_START_MONEY = 500000;\r\n\r\n    private static InGameManager innerEngine = null;\r\n\r\n    //**\r\n    // Variables\r\n    //**\r\n    private ArrayList<String> chat;\r\n    private ArrayList<String> log;\r\n    private ArrayList<Player> players;\r\n    private Dice dice;\r\n    private Board board;\r\n    private Bank bank;\r\n    private int currentPlayerId;\r\n    private GameState state;\r\n    private GameMode gameMode;\r\n\r\n    //Auction Related\r\n    private int currentBid;\r\n    private int auctionPropertyIndex;\r\n    private int currentPlayerAuctioning;\r\n    private ArrayList<Player> participants;\r\n\r\n    //Broken player related\r\n    /**\r\n     * IMPORTANT!!!!!\r\n     * THIS HASH IS THE CORE OF BANKRUPTCY\r\n     * HENCE BE AWARE USING IT\r\n     * <====VALUES====>\r\n     *      FROM 0 TO PLAYERS.SIZE-1 ===> MONEY PAYING FROM A PARTICULAR PLAYER TO OTHER PLAYERS\r\n     *      PLAYER.SIZE ===> MONEY PAYING TO BANK\r\n     *      PLAYER.SIZE + 1 ===> MONEY PAYING AS TAX\r\n     * <====STRUCTURE====>\r\n     *     PAYING PLAYER ID / WHERE TO PAY / PAYMENT AMOUNT\r\n     */\r\n    private HashMap<Integer, HashMap<Integer, Integer>> brokenPlayersMoneyHash;\r\n\r\n    //**\r\n    // Constructor\r\n    //**\r\n    private InGameManager(){\r\n    }\r\n\r\n    public static InGameManager getInstance(){\r\n        if(innerEngine == null){\r\n            innerEngine = new InGameManager();\r\n        }\r\n        return innerEngine;\r\n    }\r\n\r\n    public static synchronized void clear(){\r\n        innerEngine = new InGameManager();\r\n    }\r\n\r\n    public void initializeGame(boolean isSavedGamePlaying, GameMode mode, GameTheme theme, ArrayList<Player> players) {\r\n        if(isSavedGamePlaying){\r\n            //TODO: IMPLEMENT SAVED GAME\r\n        }else{\r\n            chat = new ArrayList<>();\r\n            log = new ArrayList<>();\r\n            this.players = players;\r\n            bank = new Bank(theme, mode);\r\n            dice = new Dice();\r\n            board = new Board(mode, theme);\r\n            currentPlayerId = 0;\r\n            state = GameState.Linear;\r\n            currentBid = 0;\r\n            auctionPropertyIndex = -1;\r\n            currentPlayerAuctioning = -1;\r\n            brokenPlayersMoneyHash = new HashMap<>();\r\n            gameMode = mode;\r\n            this.participants = new ArrayList<>();\r\n\r\n            for (Player p : players){\r\n                p.setCurrentPosition(0);\r\n                p.setStartMoney(Constants.START_MONEY);\r\n            }\r\n        }\r\n    }\r\n\r\n    //**\r\n    // Functions\r\n    //**\r\n\r\n    public ArrayList<Currency> getCurrencies(){\r\n        return this.bank.getCurrencyRates();\r\n    }\r\n\r\n    public int getCurrentPlayerCurrentPosition(){\r\n        return players.get(currentPlayerId).getCurrentPosition();\r\n    }\r\n\r\n    public PropertyCard getSpecificProperty(int squareIndex ){\r\n        for(PropertyCard p: bank.getPropertyCards()){\r\n            if(p.getId() == squareIndex){\r\n                return p;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public Player getOwner(int squareIndex){\r\n        var prop = getSpecificProperty(squareIndex);\r\n        if(prop.getOwnedBy() != -1){\r\n            return players.get(prop.getOwnedBy());\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public int saveAndExit(){\r\n        StorageUtil util = new StorageUtil();\r\n        try{\r\n            return util.saveGame(this) ? 1 : 0;\r\n        }catch (IOException e){\r\n            System.out.println(\"ERROR (3001) SAVE FAILED\");\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    public ArrayList<Integer> getSettings(){\r\n        StorageUtil util = new StorageUtil();\r\n        try{\r\n            return util.getSettings();\r\n        } catch (IOException e){\r\n            System.out.println(\"ERROR (1001): INVALID FILE\");\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public void setSettings(int audio, int music){\r\n        StorageUtil util = new StorageUtil();\r\n        try{\r\n            util.setSettings(audio, music);\r\n        }catch (IOException e){\r\n            System.out.println(\"ERROR (1002): INVALID WRITE TO FILE\");\r\n        }\r\n    }\r\n\r\n    public boolean changePlayerToBot(int index){\r\n        var player = players.get(index);\r\n        player.setHuman(false);\r\n        players.set(index, player);\r\n        return true;\r\n    }\r\n\r\n    public void addToChat(String data, String userName){\r\n        chat.add(userName + \":\\n\" + data);\r\n    }\r\n\r\n    public void addToLog(String logAction, String userName){\r\n        log.add(userName + \" has \" + logAction);\r\n    }\r\n\r\n    //**\r\n    // Bot Handlers\r\n    //**\r\n    public boolean isCurrentPlayerHuman(){\r\n        return this.players.get(currentPlayerId).isHuman();\r\n    }\r\n\r\n    /*\r\n     * RETURN VALUES\r\n     * -101 => BOT SELECTED TO ROLL DICE IN JAIL\r\n     * -100 => ERROR OCCUR\r\n     * -99 => BANKRUPT, ACCEPT DIRECTLY\r\n     * -98 => PAID DEBTS\r\n     * -97 => FREELY MADE DECISIONS\r\n     * -3 => MOVE BACKWARDS\r\n     * VALUE BETWEEN 0 TO 39 => MOVE TO INDEX\r\n     */\r\n    public void jailMakeDecision(double multiplier){\r\n        Player bot = players.get(currentPlayerId);\r\n        //Pay money and get out\r\n        bot.removeMoney(Constants.CURRENCY_NAMES[0], (int)(Bank.getJailPenalty() * multiplier));\r\n        bot.setInJail(false);\r\n        bot.resetInJailTurnCount();\r\n        bot.resetDoublesCount();\r\n    }\r\n\r\n    public int makeDecision(int diceResult, boolean isDouble){\r\n        double multiplier = 1;\r\n        if (this.gameMode ==  GameMode.bankman) {\r\n            int decision = (int)(Math.random() * 2 + 1);\r\n            if(decision == 1){\r\n                multiplier = this.generateChanceMultiplier(diceResult);\r\n            }\r\n        }\r\n\r\n        int result = startTurn(diceResult, isDouble, multiplier);\r\n\r\n        Player bot = players.get(currentPlayerId);\r\n        if(result == -100){\r\n            int jailDecision = (int) (Math.random() * 2 + 1);\r\n            if(jailDecision == 1){\r\n                //Pay money and get out\r\n                bot.removeMoney(Constants.CURRENCY_NAMES[0], (int) (Bank.getJailPenalty() * multiplier));\r\n                bot.setInJail(false);\r\n                bot.resetInJailTurnCount();\r\n                bot.resetDoublesCount();\r\n                //Make decision method again\r\n                return makeDecision(diceResult, isDouble);\r\n            }\r\n        }\r\n        else if(result == -99){\r\n            return payDebtBot(bot, multiplier);\r\n        }\r\n        else if(result == 1){\r\n            int cardRes = drawCard(DrawableCardType.Chance, multiplier);\r\n            if (cardRes == -99){\r\n                return payDebtBot(bot, multiplier);\r\n            }\r\n            else if (cardRes == -3){\r\n                return cardRes;\r\n            }\r\n            else if(cardRes >= 0 && cardRes <= 39){\r\n                return cardRes;\r\n            }\r\n        }\r\n        else if(result == 2){\r\n            int cardRes = drawCard(DrawableCardType.Community, multiplier);\r\n            if (cardRes == -99){\r\n                return payDebtBot(bot, multiplier);\r\n            }\r\n            else if (cardRes == -3){\r\n                return cardRes;\r\n            }\r\n            else if(cardRes >= 0 && cardRes <= 39){\r\n                return cardRes;\r\n            }\r\n            else if (cardRes >= 100000){\r\n                int decision = (int) (Math.random() * 2 + 1);\r\n                if(decision == 1){\r\n                    if(bot.removeMoney(Constants.CURRENCY_NAMES[0], (int)(cardRes * multiplier))){\r\n                        return -97;\r\n                    }else{\r\n                        //YİNE Mİ BATTIN BE HACI YETER YA\r\n                        return payDebtBot(bot, multiplier);\r\n                    }\r\n                }else{\r\n                    int cardResAgain = drawCard(DrawableCardType.Chance, multiplier);\r\n                    if (cardResAgain == -99){\r\n                        return payDebtBot(bot, multiplier);\r\n                    }\r\n                    else if (cardResAgain == -3){\r\n                        return cardResAgain;\r\n                    }\r\n                    else if(cardResAgain >= 0 && cardResAgain <= 39){\r\n                        return cardResAgain;\r\n                    }\r\n                }\r\n            }\r\n            else if (cardRes == 6000 || cardRes == 6100 || cardRes == 7000){\r\n                return -98;\r\n            }\r\n        }\r\n        else if(result == 7){\r\n            Square squareToBuy = board.getSquares().get(bot.getCurrentPosition());\r\n            boolean isBuyable = (squareToBuy.getType() == SquareType.NormalSquare) || (squareToBuy.getType() == SquareType.RailroadSquare) || (squareToBuy.getType() == SquareType.UtilitySquare);\r\n            if(checkBuyProperty(bot.getCurrentPosition()) && isBuyable){\r\n                //Just buy the area\r\n                buyProperty();\r\n            }\r\n            int totalBoughtProperties = bot.getOwnedPlaces().size();\r\n            int randomArea = (int)(Math.random() * totalBoughtProperties + 1);\r\n            if(checkBuildBuilding(Building.House, board.getSpecificSquare(randomArea)).containsKey(true)){\r\n                //Build house\r\n                buildBuilding(Building.House, randomArea, multiplier);\r\n            }\r\n            if(checkBuildBuilding(Building.Hotel, board.getSpecificSquare(randomArea)).containsKey(true)){\r\n                //Build hotel\r\n                buildBuilding(Building.Hotel, randomArea, multiplier);\r\n            }\r\n            return -97;\r\n        }\r\n        else {\r\n            return -99;\r\n        }\r\n        return -100;\r\n    }\r\n\r\n    //**\r\n    // Bankruptcy Handlers\r\n    //**\r\n    public boolean payDebt(double multiplier){\r\n        Player player = players.get(currentPlayerId);\r\n        var debtData = brokenPlayersMoneyHash.get(currentPlayerId);\r\n        int moneyPayIndex = debtData.entrySet().iterator().next().getKey();\r\n        int debt = debtData.get(moneyPayIndex);\r\n        if(moneyPayIndex < players.size()){\r\n            //Paying money to other player\r\n            player.removeMoney(Constants.CURRENCY_NAMES[0], (int)(debt * multiplier));\r\n            Player otherPlayer = players.get(moneyPayIndex);\r\n            otherPlayer.addMoney(Constants.CURRENCY_NAMES[0], (int)(debt * multiplier));\r\n            player.setBankrupt(false);\r\n            return true;\r\n        }else if(moneyPayIndex == players.size()){\r\n            //Paying to bank, just pay...\r\n            player.removeMoney(Constants.CURRENCY_NAMES[0], (int)(debt * multiplier));\r\n            player.setBankrupt(false);\r\n            return true;\r\n        }else if(moneyPayIndex == players.size() + 1){\r\n            //Paying to free park space :D\r\n            player.removeMoney(Constants.CURRENCY_NAMES[0], (int)(debt * multiplier));\r\n            board.addToTaxMoney(debt);\r\n            player.setBankrupt(false);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public int payDebtBot(Player bot, double multiplier){\r\n        var debtData = brokenPlayersMoneyHash.get(currentPlayerId);\r\n        int moneyPayIndex = debtData.entrySet().iterator().next().getKey();\r\n        int debt = debtData.get(moneyPayIndex);\r\n        //Look in properties\r\n        for(PropertyCard p : bot.getOwnedPlaces()){\r\n            Square s = board.getSpecificSquare(p.getId());\r\n            //Select the one with less valuable\r\n            if(s.getLevel() == 0){\r\n                //Mortgage that place\r\n                levelDown(s.getId(), multiplier);\r\n                //If has enough money\r\n                if(bot.getMonopolyMoneyAmount() >= debt){\r\n                    if(payDebt(multiplier)){\r\n                        return -98;\r\n                    }else{\r\n                        return -100;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        //Look in properties but now start to sell hotels and houses\r\n        for(PropertyCard p : bot.getOwnedPlaces()){\r\n            Square s = board.getSpecificSquare(p.getId());\r\n            //Select the first one that has hotels or houses\r\n            while(s.getLevel() > 0){\r\n                //Mortgage that place\r\n                levelDown(s.getId(), multiplier);\r\n                //If has enough money\r\n                if(bot.getMonopolyMoneyAmount() >= debt){\r\n                    if(payDebt(multiplier)){\r\n                        return -98;\r\n                    }else{\r\n                        return -100;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        //BROKE HACI GEÇMİŞ OLSUN\r\n        return -99;\r\n    }\r\n\r\n    //**\r\n    // Private Functions\r\n    //**\r\n    private String parser(int amount){\r\n        double million = 0;\r\n        double thousand = 0;\r\n        if(amount >= 1000000){\r\n            million = (float)(amount / 1000000);\r\n            double ten = million / 10;\r\n            double one = (million % 10)/10;\r\n            return \"\" + ten + one + \" M\";\r\n        }else if(amount >= 100000){\r\n            thousand = (float) (amount / 100);\r\n            return \"\" + thousand + \" K\";\r\n        }\r\n        return \"\";\r\n    }\r\n\r\n    private int getBuyer(int squareIndex){\r\n        for(PropertyCard p: bank.getPropertyCards()){\r\n            if(squareIndex == p.getId()){\r\n                return p.getOwnedBy();\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    private int countPlayersColor(Square square){\r\n        return (int) players.get(currentPlayerId).getOwnedPlaces().stream().filter(s-> s.getColor() == square.getColor()).count();\r\n    }\r\n\r\n    //**\r\n    // Turn Related Functions\r\n    //**\r\n    public void rollDice(){\r\n        dice.roll();\r\n    }\r\n\r\n    /*\r\n     * RETURN VALUES EXPLAINED\r\n     * -100 => PLAYER IN JAIL\r\n     * -99 => PLAYER BROKE, PAY DEBTS\r\n     * -2 => PLAYER DOUBLED THREE TIMES\r\n     * -1 => ERROR APPEARED SUCCESSFULLY\r\n     * 1 => DRAW CHANCE\r\n     * 2 => DRAW COMMUNITY\r\n     * 3 => PAID TAX\r\n     * 4 => GO TO JAIL\r\n     * 5 => GET TAXES FROM PARK\r\n     * 6 => PAID RENT\r\n     * 7 => EVERYTHING IS DONE, GOODBYE!\r\n     *\r\n     * JAIL ALGORITHM\r\n     * -99 => LET PLAYER PAY DEBTS, THEN startTurn() AGAIN\r\n     * -100 => LET PLAYER TO CHOOSE FROM DICE OR PAY FINE\r\n     * NO SPECIAL HANDLE IN GETTING OUT\r\n     */\r\n    public int startTurn(int diceResult, boolean hasRolledDouble, double multiplier){\r\n        /*\r\n        Basic structure of a turn is consists of:\r\n            Rolling the dice\r\n            Moving the Pawn where the dice show\r\n                If Draw Card Square -> Draw according Card\r\n                If Tax Square -> Pay Tax, the money will remain on the board\r\n                If Go To Jail Square -> Go to Jail\r\n                If Free Park -> Get the money that accumulated through paying taxes\r\n                If Property Square\r\n                    If not bought -> Buy or Pass\r\n                    If bought -> Pay Rent\r\n             After Movement, Player is released for actions but these calculations needs to be done:\r\n                If player doubled -> double count incremented\r\n                If player passed GO! Square without the help of a card, pay 2000000\r\n                Return true as turn completed\r\n         */\r\n\r\n        //If currently in auction\r\n        if(this.state == GameState.Auction){\r\n            return -1;\r\n        }\r\n\r\n        if(this.gameMode == GameMode.vanilla){\r\n            multiplier = 1;\r\n        }\r\n\r\n        //Start with getting player\r\n        Player player = players.get(currentPlayerId);\r\n\r\n        if(gameMode == GameMode.bankman){\r\n            if(player.isGetLoanCurrently()){\r\n                if(player.decrementLoanTurn()){\r\n                    if(player.getLoanTurn() == 0){\r\n                        addToLog(\"to pay loans to bank in this turn!\", player.getName());\r\n                    }else{\r\n                        addToLog(\"only \" + player.getLoanTurn() + \" turns to pay loan\", player.getName());\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if(player.isInJail()){\r\n            player.incrementInJailTurnCount();\r\n        }\r\n\r\n        if(player.isInJail() && hasRolledDouble){\r\n            player.setInJail(false);\r\n            player.resetInJailTurnCount();\r\n        }\r\n\r\n        int jailResult = checkJailStatus();\r\n        if(jailResult == 1){\r\n            return payForGetOutOfJail(multiplier);\r\n        }else if(jailResult == 2){\r\n            return -100;\r\n        }\r\n\r\n        if(hasRolledDouble){\r\n            player.incrementDoublesCount();\r\n        }\r\n        else {\r\n            player.resetDoublesCount();\r\n        }\r\n\r\n        if(player.isThreeTimesDoubled()){\r\n            player.setInJail(true);\r\n            player.setCurrentPosition(10);\r\n            player.resetDoublesCount();\r\n            return -2;\r\n        }\r\n\r\n        //Moving the Pawn where the dice show\r\n        int oldPosition = player.getCurrentPosition();\r\n        player.setCurrentPosition(oldPosition + diceResult);\r\n\r\n        if(oldPosition > player.getCurrentPosition()){\r\n            //Passed GO! Square\r\n            player.addMoney(Constants.CURRENCY_NAMES[0], (int)(Constants.GO_SQUARE_MONEY * multiplier));\r\n        }\r\n\r\n        //Get the square where pawn landed\r\n        Square square = board.getSpecificSquare(player.getCurrentPosition());\r\n\r\n        //Start If's\r\n        //If chance square\r\n        if(player.getCurrentPosition() == square.getId()){\r\n            if(square.getType() == SquareType.ChanceSquare){\r\n                return 1;\r\n            }\r\n            //If Community Chest Square\r\n            else if(square.getType() == SquareType.CommunityChestSquare){\r\n                return 2;\r\n            }\r\n            //If Tax Square\r\n            else if(square.getType() == SquareType.TaxSquare){\r\n                // Get the tax amount\r\n                int taxAmount = square.getCost();\r\n                if(player.removeMoney(Constants.CURRENCY_NAMES[0], (int) (taxAmount * multiplier))){\r\n                    addToLog(\"paid tax of \" + parser(taxAmount), player.getName());\r\n                    return 3;\r\n                }else{\r\n                    player.setBankrupt(true);\r\n                    HashMap<Integer, Integer> payHash = new HashMap<>();\r\n                    payHash.put(players.size()+1, (int)(taxAmount * multiplier));\r\n                    brokenPlayersMoneyHash.put(currentPlayerId, payHash);\r\n                    return -99;\r\n                }\r\n            }\r\n            //If Go to Jail Square\r\n            else if(square.getType() == SquareType.GoToJailSquare){\r\n                player.setCurrentPosition(10); //Move to jail hardcode\r\n                player.setInJail(true);\r\n                addToLog(\"sent to the jail\", player.getName());\r\n                return 4;\r\n            }\r\n            //If Free Parking Square, get money...\r\n            else if(square.getType() == SquareType.FreeParkingSquare){\r\n                int taxAmountOnBoard = board.getMoneyOnBoard();\r\n                if (taxAmountOnBoard != 0) {\r\n                    player.addMoney(Constants.CURRENCY_NAMES[0], (int)(taxAmountOnBoard * multiplier));\r\n                    board.removeFromTaxMoney();\r\n                    addToLog(\"got the money on the board with the amount of \" + parser(taxAmountOnBoard) + \" Monopoly Dollars\", player.getName());\r\n                }\r\n                return 5;\r\n            }else{\r\n                //If pawn of the player landed on a property square :D Hardest part coming...\r\n                if(square.isBought()){\r\n                    //Find the player who bought that square\r\n                    int buyerIdOfProperty = getBuyer(square.getId());\r\n\r\n                    //Create a dummy player holder to change players data in the end\r\n                    Player paidToPlayer = players.get(buyerIdOfProperty);\r\n\r\n                    //Find rent amount\r\n                    PropertyCard prop = getSpecificProperty(square.getId());\r\n                    assert prop != null;\r\n                    int rentAmount = 0;\r\n\r\n                    if(square.getType() == SquareType.NormalSquare){\r\n                        rentAmount = prop.getRentPrices().get(square.getRentMultiplier());\r\n                    }else if(square.getType() == SquareType.RailroadSquare){\r\n                        int counter = -1;\r\n                        for(PropertyCard p : paidToPlayer.getOwnedPlaces()){\r\n                            if(board.getSpecificSquare(p.getId()).getType() == SquareType.RailroadSquare){\r\n                                counter += 1;\r\n                            }\r\n                        }\r\n                        rentAmount = prop.getRentPrices().get(counter);\r\n                    }else if(square.getType() == SquareType.UtilitySquare){\r\n                        int counter = -1;\r\n                        for(PropertyCard p : paidToPlayer.getOwnedPlaces()){\r\n                            if(board.getSpecificSquare(p.getId()).getType() == SquareType.UtilitySquare){\r\n                                counter += 1;\r\n                            }\r\n                        }\r\n                        int baseRent = prop.getRentPrices().get(counter);\r\n                        rentAmount = baseRent * diceResult;\r\n                    }\r\n\r\n                    //Remove money from current player\r\n                    boolean isAbleToPay = player.removeMoney(Constants.CURRENCY_NAMES[0], (int)(rentAmount * multiplier));\r\n                    if(!isAbleToPay){\r\n                        player.setBankrupt(true);\r\n                        HashMap<Integer, Integer> payHash = new HashMap<>();\r\n                        payHash.put(buyerIdOfProperty, (int)(rentAmount * multiplier));\r\n                        brokenPlayersMoneyHash.put(currentPlayerId, payHash);\r\n                        return -99;\r\n                    }\r\n                    //Add money to other player\r\n                    paidToPlayer.addMoney(Constants.CURRENCY_NAMES[0], (int)(rentAmount * multiplier));\r\n\r\n                    addToLog(\"paid \" + parser(rentAmount) + \" as rent\", player.getName());\r\n                    addToLog(\"received \" + parser(rentAmount) + \" as rent income\", paidToPlayer.getName());\r\n                    return 6;\r\n                }else{\r\n                    //Not bought, this part left to frontend\r\n                    return 7;\r\n                }\r\n            }\r\n        }else{\r\n            //Error occur!\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * RETURN VALUES\r\n     * 1 => NORMAL END\r\n     * 2 => DID NOT PAID LOANS\r\n     * 3 => GAME DONE, REMAINING PLAYER WINS!\r\n     * 4 => AUCTION\r\n     */\r\n    public int endTurn(){\r\n        if(players.size() == 1){\r\n            return 3;\r\n        }\r\n\r\n        Player player = players.get(currentPlayerId);\r\n\r\n        if(player.isGetLoanCurrently() && checkHasToPayLoanBack()){\r\n            player.setBankrupt(true);\r\n        }\r\n\r\n        if (player.isInJail()){\r\n            player.incrementInJailTurnCount();\r\n        }\r\n\r\n        if(player.isBankrupt()){\r\n            //Remove player\r\n            players.remove(currentPlayerId);\r\n            //Return properties\r\n            for(PropertyCard p : player.getOwnedPlaces()){\r\n                p.setOwnedBy(-1);\r\n                Square s = board.getSpecificSquare(p.getId());\r\n                //Return houses and hotels\r\n                if(s.getHotelCount() > 0 || s.getHouseCount() > 0){\r\n                    s.setHotelCount(0);\r\n                    s.setHouseCount(0);\r\n                    s.setLevel(0);\r\n                }\r\n            }\r\n            //Return GOOJC\r\n            if(player.getSavedCards().size() != 0){\r\n                var c = player.removeFromSavedCards();\r\n                board.returnSavedCard(c);\r\n            }\r\n            currentPlayerId--;\r\n            //Clear debts :D\r\n            brokenPlayersMoneyHash.clear();\r\n        }\r\n\r\n        /*\r\n        if (gameMode.equals(GameMode.bankman)) {\r\n            // check loan for bankman mod\r\n            player.decrementLoanTurn();\r\n            if (checkHasToPayLoanBack()) {\r\n                player.setDiscardedFromGame(true);\r\n                return 2;\r\n            }\r\n        }\r\n        */\r\n\r\n        Square lastSquareMadeSomething = board.getSpecificSquare(players.get(currentPlayerId).getCurrentPosition());\r\n//        boolean isBuyable = (lastSquareMadeSomething.getType() == SquareType.NormalSquare) || (lastSquareMadeSomething.getType() == SquareType.UtilitySquare) || (lastSquareMadeSomething.getType() == SquareType.RailroadSquare);\r\n//        if(isBuyable && !lastSquareMadeSomething.isBought()){\r\n//            createAuction();\r\n//            return 4;\r\n//        }\r\n\r\n        this.currentPlayerId += 1;\r\n\r\n        if(this.currentPlayerId > players.size() - 1){\r\n            this.currentPlayerId = 0;\r\n        }\r\n\r\n        if (this.gameMode == GameMode.bankman){\r\n            changeCurrenciesOfBank();\r\n        }\r\n\r\n        return 1;\r\n    }\r\n\r\n    //**\r\n    // Action Related Functions\r\n    //**\r\n    public void buyProperty(){\r\n        //Get changing data\r\n        Player currentPlayer = players.get(currentPlayerId);\r\n        Square square = board.getSpecificSquare(currentPlayer.getCurrentPosition());\r\n        PropertyCard card = getSpecificProperty(square.getId());\r\n\r\n        //Make changes on data\r\n        card.setOwnedBy(currentPlayerId);\r\n        currentPlayer.ownProperty(getSpecificProperty(square.getId()));\r\n\r\n        //Save changes on data\r\n        //TODO ponçik ali taha olur böyle şeyler\r\n        bank.getPropertyCards().set(bank.getPropertyCards().indexOf(card), card);\r\n        board.buySquare(square.getId());\r\n\r\n        addToLog(\"bought property named : \" + card.getName(), currentPlayer.getName());\r\n    }\r\n\r\n    public void mortgagePlace(int squareIndex, double multiplier) {\r\n        Player player = players.get(getCurrentPlayerId());\r\n        player.getSpecificCard(squareIndex).setMortgaged(true);\r\n        board.getSquares().get(squareIndex).setLevel(-1);\r\n        PropertyCard currentPlace = player.getSpecificCard(squareIndex);\r\n        int moneyToAdd = currentPlace.getMortgagePrice();\r\n        player.addMoney(Constants.CURRENCY_NAMES[0], (int)(moneyToAdd * multiplier));\r\n\r\n    }\r\n    public boolean removeMortgageFromPlace(int squareIndex, double multiplier) {\r\n        Player player = players.get(getCurrentPlayerId());\r\n        PropertyCard currentPlace = player.getSpecificCard(squareIndex);\r\n        int mortgagePrice = currentPlace.getMortgagePrice();\r\n        int mortgagePenalty = (int) (mortgagePrice * PropertyCard.getMortgagePenalty());\r\n        if (player.removeMoney(Constants.CURRENCY_NAMES[0], (int)((mortgagePrice + mortgagePenalty) * multiplier))) {\r\n            player.getSpecificCard(squareIndex).setMortgaged(false);\r\n            board.getSquares().get(squareIndex).setLevel(0);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public void createAuction(){\r\n        this.state = GameState.Auction;\r\n        this.auctionPropertyIndex = players.get(currentPlayerId).getCurrentPosition();\r\n        this.currentBid = AUCTION_START_MONEY;\r\n        participants.addAll(players);\r\n        this.currentPlayerAuctioning = 0;\r\n        addToLog(\"created auction on the property\", players.get(currentPlayerId).getName());\r\n    }\r\n\r\n    public void continueAuction(int bidIncrease){\r\n        addToLog(\"increased bid by: \" + parser(bidIncrease), participants.get(currentPlayerAuctioning).getName());\r\n        this.currentPlayerAuctioning += 1;\r\n        if(this.currentPlayerAuctioning > participants.size()){\r\n            this.currentPlayerAuctioning = 0;\r\n        }\r\n        this.currentBid += bidIncrease;\r\n    }\r\n\r\n    //TODO: POSSIBLE LOGIC ERROR (but I think I solved it :D - Ali the Lele)\r\n    public void pullOffAuction(){\r\n        addToLog(\"left auction\", participants.get(currentPlayerAuctioning).getName());\r\n        participants.remove(currentPlayerAuctioning);\r\n        if(currentPlayerAuctioning == this.participants.size() - 1){\r\n            //If last player\r\n            this.currentPlayerAuctioning = -1;\r\n        }else{\r\n            this.currentPlayerAuctioning -= 1;\r\n        }\r\n        continueAuction(0);\r\n    }\r\n\r\n    public void endAuction(){\r\n        if(checkAuctionStatus()){\r\n            Player currentPlayer = participants.get(currentPlayerAuctioning);\r\n            Square square = board.getSpecificSquare(auctionPropertyIndex);\r\n            PropertyCard card = bank.getPropertyCards().get(square.getId());\r\n\r\n            //Make changes on data\r\n            card.setOwnedBy(currentPlayerAuctioning);\r\n            currentPlayer.ownProperty(getSpecificProperty(square.getId()));\r\n            bank.getPropertyCards().set(square.getId(), card);\r\n            board.buySquare(square.getId());\r\n            addToLog(\"bought property for: \" + parser(this.currentBid), participants.get(currentPlayerAuctioning).getName());\r\n\r\n            //Continue game in linear from the next player\r\n            this.currentPlayerId += 1;\r\n            if(this.currentPlayerId > players.size() - 1){\r\n                this.currentPlayerId = 0;\r\n            }\r\n\r\n            this.state = GameState.Linear;\r\n        }\r\n    }\r\n\r\n    public void buildBuilding(Building buildingType, int squareIndex, double multiplier) {\r\n        Player player = players.get(currentPlayerId);\r\n\r\n        Square squareToBuild = board.getSpecificSquare(squareIndex);\r\n        PlaceCard currentPlace = (PlaceCard) player.getSpecificCard(squareToBuild.getId());\r\n\r\n        int money;\r\n        if ( buildingType == Building.House ){\r\n            money = currentPlace.getHousePrice();\r\n            bank.decrementHouseCount();\r\n        }\r\n        else{\r\n            money = currentPlace.getHotelPrice();\r\n            bank.decrementHotelCount();\r\n        }\r\n\r\n        board.build(buildingType, squareToBuild.getId());\r\n\r\n        player.removeMoney(Constants.CURRENCY_NAMES[0], (int)(money * multiplier));\r\n\r\n        addToLog(\"built structures on the property: \" + bank.getPropertyCards().get(squareToBuild.getId()).getName(), player.getName());\r\n    }\r\n\r\n    public void destructBuilding(Building buildingType, int squareIndex, double multiplier){\r\n        Player player = players.get(currentPlayerId);\r\n\r\n        Square squareToDestruct = board.getSpecificSquare(squareIndex);\r\n        PlaceCard currentPlace = (PlaceCard) player.getSpecificCard(squareToDestruct.getId());\r\n\r\n        int money;\r\n        if ( buildingType == Building.House ){\r\n            money = (int) (currentPlace.getHousePrice() / Bank.getReturnRate());\r\n            bank.incrementHouseCount();\r\n        }\r\n        else{\r\n            money = currentPlace.getHotelPrice();\r\n            bank.decrementHotelCount();\r\n        }\r\n\r\n        board.destroy(buildingType, squareToDestruct.getId());\r\n\r\n        player.addMoney(Constants.CURRENCY_NAMES[0], (int)(money * multiplier));\r\n        addToLog(\"built structures on the property: \" + bank.getPropertyCards().get(squareToDestruct.getId()).getName(), player.getName());\r\n    }\r\n\r\n    /*\r\n     * RETURN VALUES EXPLAINED\r\n     * -99 => PLAYER BROKE\r\n     * -3 => Backward\r\n     * 0 - 39 => to index\r\n     * 5100 => DRAWN GOOJC\r\n     * 5200 => DRAWN GTJC\r\n     * 6000 => PAY MONEY FOR BUILDINGS\r\n     * 6100 => PAY TO BANK\r\n     * 7000 => BIRTHDAY GIFT BABY!\r\n     * UNKNOWN VALUE > 100000 => EITHER PAY MONEY OR DRAW CHANCE CARD\r\n     */\r\n    public int drawCard(DrawableCardType cardType, double multiplier){\r\n        if(cardType == DrawableCardType.Chance){\r\n            var cardDrawn = board.drawChanceCard();\r\n            var player = players.get(currentPlayerId);\r\n            //Algorithm\r\n            addToLog(\"drawn a chance card including message: \" + cardDrawn.getMessage(), player.getName());\r\n            if(cardDrawn.isGOOJC()){\r\n                //If card is a GOOJC, save to inventory of the current player\r\n                player.addToSavedCards(cardDrawn);\r\n                return 5100;\r\n            }else if(cardDrawn.isGTJC()){\r\n                //If card is a GTJC, move player to jail\r\n                player.setCurrentPosition(10);\r\n                player.setInJail(true);\r\n                return 5200;\r\n            }else{\r\n                if(cardDrawn.isComposed()){\r\n                    //If the card has more than one operation\r\n                    if(cardDrawn.isMoving()){\r\n                        //If requires moving, look for movement\r\n                        int moveToIndex = cardDrawn.getMoveToIndex();\r\n                        int moveInCounts = cardDrawn.getMoveInCounts();\r\n                        if(moveToIndex == -1 && moveInCounts != -1){\r\n                            //If card specifies to move forward\r\n                            //player.setCurrentPosition(player.getCurrentPosition() + moveInCounts);\r\n                            return -3;\r\n                        }else if(moveToIndex != -1 && moveInCounts == -1){\r\n                            //If card specifies to move to another square\r\n                            if(cardDrawn.isGettingMoney()){\r\n                                //If passed GO! Square during move\r\n                                int currentPosition = player.getCurrentPosition();\r\n                                if(currentPosition > moveToIndex){\r\n                                    player.addMoney(Constants.CURRENCY_NAMES[0], (int) (Constants.GO_SQUARE_MONEY * multiplier));\r\n                                }\r\n                            }\r\n                            //player.setCurrentPosition(moveToIndex);\r\n                            return moveToIndex;\r\n                        }\r\n                    }else if(cardDrawn.isRelatedToBuildings()){\r\n                        //If not moving but paying for each building owned\r\n                        var owned = player.getOwnedPlaces();\r\n                        int housesOwned = 0;\r\n                        int hotelsOwned = 0;\r\n                        for(PropertyCard c : owned){\r\n                            for(Square s : board.getSquares()){\r\n                                if(c.getId() == s.getId()){\r\n                                    housesOwned += s.getHouseCount();\r\n                                    hotelsOwned += s.getHotelCount();\r\n                                }\r\n                            }\r\n                        }\r\n                        int moneyToHotels = hotelsOwned * cardDrawn.getMoneyForHotels();\r\n                        int moneyToHoses = housesOwned * cardDrawn.getMoneyForHouses();\r\n                        if(player.removeMoney(Constants.CURRENCY_NAMES[0], (int)((moneyToHoses + moneyToHotels) * multiplier))){\r\n                            return 6000;\r\n                        }else{\r\n                            player.setBankrupt(true);\r\n                            HashMap<Integer, Integer> payHash = new HashMap<>();\r\n                            payHash.put(players.size(), (int)((moneyToHoses + moneyToHotels) * multiplier));\r\n                            brokenPlayersMoneyHash.put(currentPlayerId, payHash);\r\n                            return -99;\r\n                        }\r\n                    }\r\n                }else{\r\n                    //If not composed or moving, hence paying money\r\n                    if(player.removeMoney(Constants.CURRENCY_NAMES[0], (int)(cardDrawn.getMoneyOwe() * multiplier))){\r\n                        return 6100;\r\n                    }else{\r\n                        player.setBankrupt(true);\r\n                        HashMap<Integer, Integer> payHash = new HashMap<>();\r\n                        payHash.put(players.size(), (int)(cardDrawn.getMoneyOwe() * multiplier));\r\n                        brokenPlayersMoneyHash.put(currentPlayerId, payHash);\r\n                        return -99;\r\n                    }\r\n                }\r\n            }\r\n        }else{\r\n            var cardDrawn = board.drawCommunityChestCard();\r\n            var player = players.get(currentPlayerId);\r\n            addToLog(\"drawn a community chest card including message: \" + cardDrawn.getMessage(), player.getName());\r\n            if(cardDrawn.isGOOJC()){\r\n                //If card is a GOOJC, save to inventory of the current player\r\n                player.addToSavedCards(cardDrawn);\r\n                return 5100;\r\n            }else if(cardDrawn.isGTJC()){\r\n                //If card is a GTJC, move player to jail\r\n                player.setCurrentPosition(10);\r\n                player.setInJail(true);\r\n                return 5200;\r\n            }else if(cardDrawn.isDrawingChanceCard()){\r\n                //Needed to be handled in front-end.\r\n                return cardDrawn.getMoneyOwe();\r\n            }else{\r\n                if(cardDrawn.isComposed()){\r\n                    //If the card has more than one operation\r\n                    if(cardDrawn.isMoving()){\r\n                        //If requires moving, look for movement\r\n                        int moveToIndex = cardDrawn.getMoveToIndex();\r\n                        int moveInCounts = cardDrawn.getMoveInCounts();\r\n                        if(moveToIndex == -1 && moveInCounts != -1){\r\n                            //If card specifies to move forward\r\n                            //player.setCurrentPosition(player.getCurrentPosition() + moveInCounts);\r\n                            return -3;\r\n                        }else if(moveToIndex != -1 && moveInCounts == -1){\r\n                            //If card specifies to move to another square\r\n                            if(cardDrawn.isGettingMoney()){\r\n                                //If passed GO! Square during move\r\n                                int currentPosition = player.getCurrentPosition();\r\n                                if(currentPosition > moveToIndex){\r\n                                    player.addMoney(Constants.CURRENCY_NAMES[0], (int)(Constants.GO_SQUARE_MONEY * multiplier));\r\n                                }\r\n                            }\r\n                            //player.setCurrentPosition(moveToIndex);\r\n                            return moveToIndex;\r\n                        }\r\n                    }else if(cardDrawn.isRelatedToBuildings()){\r\n                        //If not moving but paying for each building owned\r\n                        var owned = player.getOwnedPlaces();\r\n                        int housesOwned = 0;\r\n                        int hotelsOwned = 0;\r\n                        for(PropertyCard c : owned){\r\n                            for(Square s : board.getSquares()){\r\n                                if(c.getId() == s.getId()){\r\n                                    housesOwned += s.getHouseCount();\r\n                                    hotelsOwned += s.getHotelCount();\r\n                                }\r\n                            }\r\n                        }\r\n                        int moneyToHouses = housesOwned * cardDrawn.getMoneyForHouses();\r\n                        int moneyForHotels = hotelsOwned * cardDrawn.getMoneyForHotels();\r\n                        if(player.removeMoney(Constants.CURRENCY_NAMES[0], (int)((moneyToHouses + moneyForHotels) * multiplier))){\r\n                            return 6000;\r\n                        }else{\r\n                            player.setBankrupt(true);\r\n                            HashMap<Integer, Integer> payHash = new HashMap<>();\r\n                            payHash.put(players.size(), (int)((moneyToHouses + moneyForHotels) * multiplier));\r\n                            brokenPlayersMoneyHash.put(currentPlayerId, payHash);\r\n                            return -99;\r\n                        }\r\n                    }else if(cardDrawn.isEachPlayerIncluded()){\r\n                        //Or paying money to other players\r\n                        for (int i = 0; i < players.size(); i++) {\r\n                            if(i != currentPlayerId){\r\n                                var otherPlayer = players.get(i);\r\n                                boolean ableToPay = otherPlayer.removeMoney(Constants.CURRENCY_NAMES[0], (int)(cardDrawn.getMoneyOwe() * multiplier));\r\n                                if(!ableToPay){\r\n                                    otherPlayer.setBankrupt(true);\r\n                                }\r\n                            }\r\n                        }\r\n                        player.addMoney(Constants.CURRENCY_NAMES[0], (int)((cardDrawn.getMoneyOwe() * players.size() - 1) * multiplier));\r\n                        return 7000;\r\n                    }\r\n                }else{\r\n                    //If not composed or moving, hence paying money\r\n                    if(player.removeMoney(Constants.CURRENCY_NAMES[0], (int)(cardDrawn.getMoneyOwe() * multiplier))){\r\n                        return 6100;\r\n                    }else{\r\n                        player.setBankrupt(true);\r\n                        HashMap<Integer, Integer> payHash = new HashMap<>();\r\n                        payHash.put(players.size(), (int)(cardDrawn.getMoneyOwe() * multiplier));\r\n                        brokenPlayersMoneyHash.put(currentPlayerId, payHash);\r\n                        return -99;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    public void levelUp(int squareIndex, double multiplier){\r\n        Square square = board.getSpecificSquare(squareIndex);\r\n        int level = square.getLevel();\r\n\r\n        if (level == -1){\r\n            removeMortgageFromPlace(squareIndex, multiplier);\r\n        }\r\n        else if (level == 0 && !square.isBought()){\r\n            buyProperty();\r\n        }\r\n        else if(level == 0 && square.isBought()){\r\n            buildBuilding(Building.House, squareIndex, multiplier);\r\n        }\r\n        else if(level == 1){\r\n            buildBuilding(Building.House, squareIndex, multiplier);\r\n        }\r\n        else if(level == 2){\r\n            buildBuilding(Building.House, squareIndex, multiplier);\r\n        }\r\n        else if(level == 3){\r\n            buildBuilding(Building.House, squareIndex, multiplier);\r\n        }\r\n        else if(level == 4){\r\n            buildBuilding(Building.Hotel, squareIndex, multiplier);\r\n        }\r\n    }\r\n\r\n    public void levelDown(int squareIndex, double multiplier){\r\n        Square square = board.getSpecificSquare(squareIndex);\r\n        int level = square.getLevel();\r\n\r\n        if (level == 5){\r\n            destructBuilding(Building.Hotel, squareIndex, multiplier);\r\n        }\r\n        else if(level == 4){\r\n            destructBuilding(Building.House, squareIndex, multiplier);\r\n        }\r\n        else if(level == 3){\r\n            destructBuilding(Building.House, squareIndex, multiplier);\r\n        }\r\n        else if(level == 2){\r\n            destructBuilding(Building.House, squareIndex, multiplier);\r\n        }\r\n        else if(level == 1){\r\n            destructBuilding(Building.House, squareIndex, multiplier);\r\n        }\r\n        else if(level == 0){\r\n            mortgagePlace(squareIndex, multiplier);\r\n        }\r\n    }\r\n\r\n    /*\r\n     * RETURN VALUES\r\n     * 1 => PAID AND SET FREE\r\n     * -99 => CAN NOT PAID AND HAS TO PAY DEBTS\r\n     * 3 => NOT EVEN IN JAIL\r\n     */\r\n    public int payForGetOutOfJail(double multiplier) {\r\n        Player player = players.get(currentPlayerId);\r\n        if (player.isInJail()) {\r\n            if (player.removeMoney(Constants.CURRENCY_NAMES[0], (int)(Bank.getJailPenalty() * multiplier))) {\r\n                player.setInJail(false);\r\n                player.resetInJailTurnCount();\r\n                return 1;\r\n            }\r\n            else {\r\n                player.setBankrupt(true); // player has gone bankrupt\r\n                HashMap<Integer, Integer> payHash = new HashMap<>();\r\n                payHash.put(players.size(), (int)(Bank.getJailPenalty() * multiplier));\r\n                brokenPlayersMoneyHash.put(currentPlayerId, payHash);\r\n                return -99; // player has not enough money to get out of jail, go bankrupt\r\n            }\r\n        }\r\n        return 3; // player is not even in jail, control return\r\n    }\r\n\r\n    //**\r\n    // Bankman Mode Functions\r\n    //**\r\n    public boolean giveLoan(int amount) {\r\n        Player player = players.get(currentPlayerId);\r\n        if (player.isGetLoanCurrently()) {\r\n            System.out.println(\"You need to pay your loan first\");\r\n            return false;\r\n        }\r\n        System.out.println(\"Gave loan to the player \" + player.getName());\r\n        addToLog(\"got loan in amount \" + parser(amount), player.getName());\r\n        bank.giveLoan(amount, player);\r\n        return true;\r\n    }\r\n\r\n    public boolean receiveLoanBackFromPlayer(double multiplier) {\r\n        Player player = players.get(currentPlayerId);\r\n        if (!player.isGetLoanCurrently()) {\r\n            System.out.println(\"The player is not on the loan currently\");\r\n            return false;\r\n        }\r\n        int amount = player.getLoan();\r\n        if(player.removeMoney(Constants.CURRENCY_NAMES[0], (int)(amount * multiplier))){\r\n            System.out.println(\"Player paid his/her loan \" + player.getName());\r\n            addToLog(\"paid loan back with amount of: \" + parser(amount), player.getName());\r\n            player.resetLoan();\r\n            return true;\r\n        }else{\r\n            player.setBankrupt(true);\r\n            HashMap<Integer, Integer> payHash = new HashMap<>();\r\n            payHash.put(players.size(), (int)(amount * multiplier));\r\n            brokenPlayersMoneyHash.put(currentPlayerId, payHash);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public boolean checkHasToPayLoanBack() {\r\n        Player player = players.get(currentPlayerId);\r\n        if (player.getLoanTurn() == 0) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public void changeCurrenciesOfBank() {\r\n        // call this function in the end of the each turn\r\n        this.bank.changeCurrencies();\r\n    }\r\n\r\n    public int exchangeCurrency(String fromCurrency, String toCurrency, int amount) {\r\n        Player player = players.get(currentPlayerId);\r\n        return this.bank.exchangeMoney(player, fromCurrency, toCurrency, amount);\r\n    }\r\n\r\n    public double generateChanceMultiplier(int diceResult) {\r\n        double result;\r\n        int randomResult = (int) ((Math.random() * (12 - 1)) + 1);\r\n        if (randomResult >= 1 && randomResult <= 3) {\r\n            result = 0.5;\r\n        }\r\n        else if (randomResult >= 4 && randomResult <= 6) {\r\n            result = 1;\r\n        }\r\n        else if (randomResult >= 7 && randomResult <= 9) {\r\n            result = 1.5;\r\n        }\r\n        else {\r\n            result = 2.0;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    //**\r\n    // Checker Functions\r\n    //**\r\n\r\n    /*\r\n     * RETURN VALUES\r\n     * -1 => NOT IN JAIL\r\n     * 1 => HAS TO GET OUT\r\n     * 2 => HAS NOT ENOUGH MONEY / BROKE\r\n     * 3 => IN JAIL\r\n     */\r\n    public int checkJailStatus() {\r\n        Player player = players.get(currentPlayerId);\r\n        if (!player.isInJail()) {\r\n            return -1; // Player is not in jail\r\n        }\r\n        int jailTurnCount = player.getInJailTurnCount();\r\n        if (jailTurnCount == JAIL_TURN_COUNT) {\r\n            return 1; // the player has to go out right now\r\n        }\r\n        if(player.getMonopolyMoneyAmount() >= Bank.getJailPenalty()){\r\n            return 2; // the player has enough money to get out of jail\r\n        }\r\n        return 3; // the player has not enough money to get out of jail\r\n    }\r\n\r\n\r\n    public HashMap<String, Boolean> checkLevelStatus(int squareIndex){\r\n        Player player = players.get(currentPlayerId);\r\n        Square square = board.getSpecificSquare(squareIndex);\r\n        PropertyCard card = getSpecificProperty(squareIndex);\r\n\r\n        HashMap<String, Boolean> returningHash = new HashMap<>();\r\n\r\n        if(currentPlayerId == card.getOwnedBy()){\r\n            if(checkBuildBuilding(Building.House, square).containsKey(true) || checkBuildBuilding(Building.Hotel, square).containsKey(true) || checkDismortgage(player, square)){\r\n                returningHash.put(\"levelUp\", true);\r\n            } else{\r\n                returningHash.put(\"levelUp\", false);\r\n            }\r\n\r\n            if(checkDestructBuilding(Building.House, square).containsKey(true) || checkDestructBuilding(Building.Hotel, square).containsKey(true) || checkMortgage(player, square)){\r\n                returningHash.put(\"levelDown\", true);\r\n            } else{\r\n                returningHash.put(\"levelDown\", false);\r\n            }\r\n        }\r\n        else if(currentPlayerId != card.getOwnedBy() && card.getOwnedBy() != -1){\r\n            returningHash.put(\"levelUp\", false);\r\n            returningHash.put(\"levelDown\", false);\r\n        }\r\n        else {\r\n            if (checkBuyProperty(squareIndex)){\r\n                returningHash.put(\"levelUp\", true);\r\n            }\r\n            else {\r\n                returningHash.put(\"levelUp\", false);\r\n            }\r\n            returningHash.put(\"levelDown\", false);\r\n        }\r\n        return returningHash;\r\n    }\r\n\r\n    public boolean checkBrokenStatus(){\r\n        for(Player p : players){\r\n            if(p.isBankrupt()){\r\n                this.state = GameState.Broken;\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public boolean checkAuctionStatus(){\r\n        return participants.size() == 1;\r\n    }\r\n\r\n    public boolean checkMortgage(Player currentPlayer, Square squareToMortgage){\r\n\r\n        int squareId = squareToMortgage.getId();\r\n        int squareLevel = squareToMortgage.getLevel();\r\n        PropertyCard currentPlace = currentPlayer.getSpecificCard(squareId);\r\n\r\n        if ( currentPlayer.isOwned(currentPlace ) && squareLevel == 0 ) {\r\n            //System.out.println(\"Player can mortgage this place\");\r\n            return true;\r\n        }\r\n        //System.out.println(\"Player cannot mortgage this place\");\r\n        return false;\r\n    }\r\n\r\n    public boolean checkDismortgage( Player currentPlayer, Square squareToDismortgage){\r\n        int squareId = squareToDismortgage.getId();\r\n        int squareLevel = squareToDismortgage.getLevel();\r\n        PropertyCard currentPlace = currentPlayer.getSpecificCard(squareId);\r\n        int dismortgageMoney = (int) (currentPlace.getMortgagePrice() * 1.10);\r\n\r\n        if (currentPlayer.isOwned(currentPlace)) {\r\n            if (squareLevel == -1){\r\n                if (currentPlayer.getMonopolyMoneyAmount() >= dismortgageMoney){\r\n                    //System.out.println(\"Player can dismortgage\");\r\n                    return true;\r\n                }\r\n                else {\r\n                    //System.out.println(\"player does not have enough money to dismortgage\");\r\n                }\r\n            }\r\n            else {\r\n                //System.out.println(\"This square is not mortgaged\");\r\n            }\r\n        }\r\n        else{\r\n            //System.out.println(\"Player does not have this place\");\r\n        }\r\n        return false;\r\n    }\r\n    public boolean checkBuyProperty(int index){\r\n        Player currentPlayer = players.get(currentPlayerId);\r\n        Square squareToBuy = board.getSpecificSquare(index);\r\n        PropertyCard toGetCostOfPropertyCard = getSpecificProperty(squareToBuy.getId());\r\n        boolean isBuyable = (squareToBuy.getType() == SquareType.NormalSquare) || (squareToBuy.getType() == SquareType.UtilitySquare) || (squareToBuy.getType() == SquareType.RailroadSquare);\r\n        if (isBuyable && currentPlayer.getCurrentPosition() == squareToBuy.getId()){\r\n            if (!squareToBuy.isBought()){\r\n                if (currentPlayer.getMonopolyMoneyAmount() >= toGetCostOfPropertyCard.getCost()){\r\n                    return true;\r\n                }\r\n                else {\r\n                    //System.out.println(\"Player does not have enough money\");\r\n                    return false;\r\n                }\r\n            }\r\n            else {\r\n                //System.out.println(\"square is already bought\");\r\n                return false;\r\n            }\r\n        }\r\n        else {\r\n            //System.out.println(\"Player is not on this square\");\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public Map<Boolean, Integer> checkBuildBuilding(Building buildingType, Square squareToBuild){\r\n        // Also, maybe the algorithm can change, according to the rulebook\r\n        Map<Boolean, Integer> checkAndCountHouses = new HashMap<>();\r\n        Map<Boolean, Integer> checkAndCountHotel = new HashMap<>();\r\n        if(squareToBuild.getType() == SquareType.NormalSquare){// TODO: Check house&hotel count of bank\r\n\r\n\r\n            //IF NO BUILDINGS AVAILABLE\r\n            if(!bank.checkBuildingAvailability(buildingType)){\r\n                if(buildingType == Building.House){\r\n                    checkAndCountHouses.put(false, 0);\r\n                    return checkAndCountHouses;\r\n                }else if(buildingType == Building.Hotel){\r\n                    checkAndCountHotel.put(false, 0);\r\n                    return checkAndCountHotel;\r\n                }\r\n            }\r\n\r\n            Player currentPlayer = players.get(currentPlayerId);\r\n\r\n            int squareToBuildIndex = squareToBuild.getId();\r\n\r\n            int colorsCountOnBoard = board.countColors(squareToBuild);\r\n            int colorsCountOnPlayer = countPlayersColor(squareToBuild);\r\n            int houseCountOnSquare = squareToBuild.getHouseCount();\r\n            int hotelCountOnSquare = squareToBuild.getHotelCount();\r\n            int currentMoney = currentPlayer.getMonopolyMoneyAmount();\r\n            int squareLevel = squareToBuild.getLevel();\r\n\r\n            PlaceCard currentPlace = (PlaceCard) currentPlayer.getSpecificCard(squareToBuildIndex);\r\n\r\n            if ( colorsCountOnBoard == colorsCountOnPlayer ){   // Checks player has all squares with same the color (is there a mortgage or not check it!!!)\r\n                if ( buildingType == Building.House && squareLevel < 4 && squareLevel > -1 ){\r\n\r\n                    int priceOfAHouse = currentPlace.getHousePrice();\r\n\r\n                    if (squareToBuild.isHouseCheck()){  // Checks the square has a house once or not\r\n\r\n                        if (board.hasHouseAllSquares(squareToBuild)){   // Checks other squares have houses or not\r\n                            int availableHouses = 4 - houseCountOnSquare;\r\n                            int count = 0;\r\n                            for ( int i = 1; i <= availableHouses; i++ ) {    // Calculates how many houses can be bought with player's money\r\n                                if (currentMoney >= i * priceOfAHouse){\r\n                                    count++;\r\n                                }\r\n                            }\r\n                            if (count > 0) { // checks if count is positive, count houses can be bought\r\n                                checkAndCountHouses.put(true, count);\r\n                                //System.out.println(\"Player can buy \" + count + \" houses on this square\");\r\n                            }\r\n                            else {  // player cannot buy a house\r\n                                checkAndCountHouses.put(false, 0);\r\n                                //System.out.println(\"Max number of houses or not enough money\");\r\n                            }\r\n                        }\r\n                        else if ( !board.hasHouseAllSquares(squareToBuild) && houseCountOnSquare > 0 ){ // if there is one house and other squares don't have a house\r\n                            checkAndCountHouses.put(false, 0);\r\n                            //System.out.println(\"Player has already a house in this square\");\r\n                        }\r\n                        else if ( !board.hasHouseAllSquares(squareToBuild) && houseCountOnSquare == 0 ){\r\n                            if ( currentMoney > priceOfAHouse && currentPlayer.getCurrentPosition() == squareToBuildIndex ){    // checks player's money is enough for a house\r\n                                checkAndCountHouses.put(true, 1);\r\n                                //System.out.println(\"Player can buy a house\");\r\n                            }\r\n                            else {\r\n                                checkAndCountHouses.put(false, 0);\r\n                                //System.out.println(\"Not sufficient money or player is not on that square\");\r\n                            }\r\n                        }\r\n                    }\r\n                    else {  // if the square has no house\r\n                        if ( currentMoney > priceOfAHouse && currentPlayer.getCurrentPosition() == squareToBuildIndex ){    // checks player's money is enough for a house\r\n                            checkAndCountHouses.put(true, 1);\r\n                            //System.out.println(\"Player can buy a house\");\r\n                        }\r\n                        else {\r\n                            checkAndCountHouses.put(false, 0);\r\n                            //System.out.println(\"Not sufficient money or player is not on that square\");\r\n                        }\r\n                    }\r\n                    return checkAndCountHouses;\r\n                }\r\n                if ( buildingType == Building.Hotel && squareLevel == 4){\r\n                    if ( (houseCountOnSquare == 4 && hotelCountOnSquare == 0)) { // checks square has 4 houses\r\n                        int priceOfAHotel = currentPlace.getHotelPrice();\r\n                        if ( currentMoney > priceOfAHotel ){ // checks money is enough or not\r\n                            checkAndCountHotel.put(true, 1);\r\n                            //System.out.println(\"Player can buy an hotel\");\r\n\r\n                        }\r\n                        else {  //money is not enough\r\n                            checkAndCountHotel.put(false, 0);\r\n                            //System.out.println(\"Not sufficient money\");\r\n                        }\r\n                    }\r\n                    else {  // houses are not enough or there is an hotel\r\n                        checkAndCountHotel.put(false, 0);\r\n                        //System.out.println(\"not enough houses or there is an hotel\");\r\n                    }\r\n                    return checkAndCountHotel;\r\n                }\r\n                else{\r\n\r\n                    checkAndCountHouses.put(false, 0);\r\n                    //System.out.println(\"place is mortgaged\");\r\n                }\r\n            }\r\n            else{   // player does not have all squares with that color\r\n                checkAndCountHouses.put(false, 0);\r\n                //System.out.println(\"Player haven't got all squares with that color\");\r\n            }\r\n\r\n        }\r\n        else{\r\n            checkAndCountHouses.put(false, 0);\r\n        }\r\n        return checkAndCountHouses;\r\n    }\r\n    public Map<Boolean, Integer> checkDestructBuilding(Building buildingType, Square squareToDestruct){\r\n        // Also, maybe the algorithm can change, according to the rulebook\r\n\r\n        Map<Boolean, Integer> checkAndCountHousesDestruct = new HashMap<>();\r\n        Map<Boolean, Integer> checkAndCountHotelDestruct = new HashMap<>();\r\n        if (squareToDestruct.getType() == SquareType.NormalSquare){\r\n            Player currentPlayer = players.get(currentPlayerId);\r\n\r\n            int houseCountOnSquare = squareToDestruct.getHouseCount();\r\n            int hotelCountOnSquare = squareToDestruct.getHotelCount();\r\n\r\n            int squareToDestructId = squareToDestruct.getId();\r\n            PlaceCard currentPlace = (PlaceCard) currentPlayer.getSpecificCard(squareToDestructId);\r\n\r\n            if ( currentPlace != null ){\r\n                if ( buildingType == Building.Hotel) {\r\n                    if ( hotelCountOnSquare == 1 ) {\r\n                        checkAndCountHotelDestruct.put(true, 1);\r\n                        //System.out.println(\"Player can destruct an hotel\");\r\n                    }\r\n                    else{\r\n                        checkAndCountHotelDestruct.put(false, 0);\r\n                        //System.out.println(\"there is no hotel to destruct\");\r\n                    }\r\n                    return checkAndCountHotelDestruct;\r\n\r\n                }\r\n                if ( buildingType == Building.House ) {\r\n                    if (houseCountOnSquare > 0) {\r\n                        checkAndCountHousesDestruct.put(true, hotelCountOnSquare);\r\n                        //System.out.println(\"Player can destruct \" + hotelCountOnSquare + \" houses \");\r\n                    }\r\n                    else {\r\n                        checkAndCountHousesDestruct.put(false, 0);\r\n                        //System.out.println(\"There is no house to destruct\");\r\n                    }\r\n                    return checkAndCountHousesDestruct;\r\n                }\r\n            }\r\n            else {\r\n                checkAndCountHousesDestruct.put(false, 0);\r\n                //System.out.println(\"Player does not have this square\");\r\n                return checkAndCountHousesDestruct;\r\n            }\r\n        }\r\n\r\n        checkAndCountHousesDestruct.put(false, 0);\r\n        return checkAndCountHousesDestruct;\r\n\r\n    }\r\n\r\n\r\n    //Getters and Setters\r\n\r\n    public ArrayList<String> getChat() {\r\n        return chat;\r\n    }\r\n\r\n    public void setChat(ArrayList<String> chat) {\r\n        this.chat = chat;\r\n    }\r\n\r\n    public ArrayList<String> getLog() {\r\n        return log;\r\n    }\r\n\r\n    public void setLog(ArrayList<String> log) {\r\n        this.log = log;\r\n    }\r\n\r\n    public ArrayList<Player> getPlayers() {\r\n        return players;\r\n    }\r\n\r\n    public void setPlayers(ArrayList<Player> players) {\r\n        this.players = players;\r\n    }\r\n\r\n    public Dice getDice() {\r\n        return dice;\r\n    }\r\n\r\n    public void setDice(Dice dice) {\r\n        this.dice = dice;\r\n    }\r\n\r\n    public Board getBoard() {\r\n        return board;\r\n    }\r\n\r\n    public void setBoard(Board board) {\r\n        this.board = board;\r\n    }\r\n\r\n    public Bank getBank() {\r\n        return bank;\r\n    }\r\n\r\n    public void setBank(Bank bank) {\r\n        this.bank = bank;\r\n    }\r\n\r\n    public int getCurrentPlayerId() {\r\n        return currentPlayerId;\r\n    }\r\n\r\n    public void setCurrentPlayerId(int currentPlayerId) {\r\n        this.currentPlayerId = currentPlayerId;\r\n    }\r\n\r\n    public GameState getState() {\r\n        return state;\r\n    }\r\n\r\n    public void setState(GameState state) {\r\n        this.state = state;\r\n    }\r\n\r\n    public GameMode getGameMode() {\r\n        return gameMode;\r\n    }\r\n\r\n    public void setGameMode(GameMode gameMode) {\r\n        this.gameMode = gameMode;\r\n    }\r\n\r\n    public int getCurrentBid() {\r\n        return currentBid;\r\n    }\r\n\r\n    public void setCurrentBid(int currentBid) {\r\n        this.currentBid = currentBid;\r\n    }\r\n\r\n    public int getAuctionPropertyIndex() {\r\n        return auctionPropertyIndex;\r\n    }\r\n\r\n    public void setAuctionPropertyIndex(int auctionPropertyIndex) {\r\n        this.auctionPropertyIndex = auctionPropertyIndex;\r\n    }\r\n\r\n    public int getCurrentPlayerAuctioning() {\r\n        return currentPlayerAuctioning;\r\n    }\r\n\r\n    public void setCurrentPlayerAuctioning(int currentPlayerAuctioning) {\r\n        this.currentPlayerAuctioning = currentPlayerAuctioning;\r\n    }\r\n\r\n    public ArrayList<Player> getParticipants() {\r\n        return participants;\r\n    }\r\n\r\n    public void setParticipants(ArrayList<Player> participants) {\r\n        this.participants = participants;\r\n    }\r\n\r\n    public HashMap<Integer, HashMap<Integer, Integer>> getBrokenPlayersMoneyHash() {\r\n        return brokenPlayersMoneyHash;\r\n    }\r\n\r\n    public void setBrokenPlayersMoneyHash(HashMap<Integer, HashMap<Integer, Integer>> brokenPlayersMoneyHash) {\r\n        this.brokenPlayersMoneyHash = brokenPlayersMoneyHash;\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Yolopoly/src/main/java/com/yolopoly/managers/InGameManager.java	(revision ee870a899aa6a5c743fefffaae1e6a85b929dab2)
+++ Yolopoly/src/main/java/com/yolopoly/managers/InGameManager.java	(date 1608408101535)
@@ -806,7 +806,7 @@
 
         player.removeMoney(Constants.CURRENCY_NAMES[0], (int)(money * multiplier));
 
-        addToLog("built structures on the property: " + bank.getPropertyCards().get(squareToBuild.getId()).getName(), player.getName());
+        addToLog("built structures on the property: " + currentPlace.getName(), player.getName());
     }
 
     public void destructBuilding(Building buildingType, int squareIndex, double multiplier){
Index: Yolopoly/Yolopoly.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<module org.jetbrains.idea.maven.project.MavenProjectsManager.isMavenModule=\"true\" type=\"JAVA_MODULE\" version=\"4\">\r\n  <component name=\"NewModuleRootManager\" LANGUAGE_LEVEL=\"JDK_15\">\r\n    <output url=\"file://$MODULE_DIR$/target/classes\" />\r\n    <output-test url=\"file://$MODULE_DIR$/target/test-classes\" />\r\n    <content url=\"file://$MODULE_DIR$\">\r\n      <sourceFolder url=\"file://$MODULE_DIR$/src/main/java\" isTestSource=\"false\" />\r\n      <sourceFolder url=\"file://$MODULE_DIR$/src/test/java\" isTestSource=\"true\" />\r\n      <sourceFolder url=\"file://$MODULE_DIR$/src/main/resources\" type=\"java-resource\" />\r\n      <excludeFolder url=\"file://$MODULE_DIR$/target\" />\r\n    </content>\r\n    <orderEntry type=\"inheritedJdk\" />\r\n    <orderEntry type=\"sourceFolder\" forTests=\"false\" />\r\n    <orderEntry type=\"library\" name=\"Maven: org.openjfx:javafx-controls:mac:15.0.1\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: org.openjfx:javafx-graphics:mac:15.0.1\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: org.openjfx:javafx-base:mac:15.0.1\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: org.openjfx:javafx-fxml:mac:15\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.firebase:firebase-admin:7.1.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.api-client:google-api-client:1.30.10\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.http-client:google-http-client-jackson2:1.36.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.api-client:google-api-client-gson:1.30.10\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.http-client:google-http-client-gson:1.36.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.http-client:google-http-client:1.35.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: org.apache.httpcomponents:httpclient:4.5.12\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: org.apache.httpcomponents:httpcore:4.4.13\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.j2objc:j2objc-annotations:1.3\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: io.opencensus:opencensus-api:0.24.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: io.opencensus:opencensus-contrib-http-util:0.24.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.api:api-common:1.9.2\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: javax.annotation:javax.annotation-api:1.3.2\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.auto.value:auto-value-annotations:1.7.2\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.auth:google-auth-library-oauth2-http:0.20.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.auth:google-auth-library-credentials:0.20.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.cloud:google-cloud-storage:1.110.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.guava:failureaccess:1.0.1\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.guava:listenablefuture:9999.0-empty-to-avoid-conflict-with-guava\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: org.checkerframework:checker-compat-qual:2.5.5\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.errorprone:error_prone_annotations:2.3.4\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.fasterxml.jackson.core:jackson-core:2.11.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.apis:google-api-services-storage:v1-rev20200430-1.30.9\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.code.gson:gson:2.8.6\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.cloud:google-cloud-core:1.93.6\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.cloud:google-cloud-core-http:1.93.6\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.http-client:google-http-client-appengine:1.35.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.api:gax-httpjson:0.74.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.api:gax:1.57.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.api.grpc:proto-google-iam-v1:0.13.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.protobuf:protobuf-java:3.12.2\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.protobuf:protobuf-java-util:3.12.2\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: org.threeten:threetenbp:1.4.4\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.cloud:google-cloud-firestore:1.35.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.cloud:google-cloud-core-grpc:1.93.6\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: io.grpc:grpc-core:1.30.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" scope=\"RUNTIME\" name=\"Maven: com.google.android:annotations:4.1.1.4\" level=\"project\" />\r\n    <orderEntry type=\"library\" scope=\"RUNTIME\" name=\"Maven: io.perfmark:perfmark-api:0.19.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: commons-logging:commons-logging:1.2\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: commons-codec:commons-codec:1.11\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.api.grpc:proto-google-cloud-firestore-admin-v1:1.35.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.api.grpc:proto-google-cloud-firestore-v1:1.35.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.api.grpc:proto-google-cloud-firestore-v1beta1:0.88.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: io.opencensus:opencensus-contrib-grpc-util:0.24.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: io.grpc:grpc-protobuf:1.30.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: io.grpc:grpc-protobuf-lite:1.30.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" scope=\"RUNTIME\" name=\"Maven: org.codehaus.mojo:animal-sniffer-annotations:1.18\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.api:gax-grpc:1.57.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: io.grpc:grpc-auth:1.30.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: io.grpc:grpc-netty-shaded:1.30.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: io.grpc:grpc-alts:1.30.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: io.grpc:grpc-grpclb:1.30.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: org.apache.commons:commons-lang3:3.5\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: org.conscrypt:conscrypt-openjdk-uber:2.2.1\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: io.grpc:grpc-stub:1.30.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.guava:guava:29.0-android\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: org.slf4j:slf4j-api:1.7.25\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: io.netty:netty-codec-http:4.1.50.Final\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: io.netty:netty-common:4.1.50.Final\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: io.netty:netty-buffer:4.1.50.Final\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: io.netty:netty-codec:4.1.50.Final\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: io.netty:netty-handler:4.1.50.Final\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: io.netty:netty-resolver:4.1.50.Final\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: io.netty:netty-transport:4.1.50.Final\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.oauth-client:google-oauth-client:1.30.4\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: org.openjfx:javafx-controls:15.0.1\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: org.openjfx:javafx-controls:win:15.0.1\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: org.openjfx:javafx-graphics:15.0.1\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: org.openjfx:javafx-graphics:win:15.0.1\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: org.openjfx:javafx-base:15.0.1\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: org.openjfx:javafx-base:win:15.0.1\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: org.openjfx:javafx-fxml:15\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: org.openjfx:javafx-fxml:win:15\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: org.json:json:20201115\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.firebase:firebase-admin:7.1.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.api-client:google-api-client:1.30.10\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.http-client:google-http-client-jackson2:1.36.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.api-client:google-api-client-gson:1.30.10\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.http-client:google-http-client-gson:1.36.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.http-client:google-http-client:1.35.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: org.apache.httpcomponents:httpclient:4.5.12\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: org.apache.httpcomponents:httpcore:4.4.13\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.j2objc:j2objc-annotations:1.3\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: io.opencensus:opencensus-api:0.24.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: io.opencensus:opencensus-contrib-http-util:0.24.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.api:api-common:1.9.2\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: javax.annotation:javax.annotation-api:1.3.2\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.auto.value:auto-value-annotations:1.7.2\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.auth:google-auth-library-oauth2-http:0.20.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.auth:google-auth-library-credentials:0.20.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.cloud:google-cloud-storage:1.110.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.guava:failureaccess:1.0.1\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.guava:listenablefuture:9999.0-empty-to-avoid-conflict-with-guava\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: org.checkerframework:checker-compat-qual:2.5.5\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.errorprone:error_prone_annotations:2.3.4\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.fasterxml.jackson.core:jackson-core:2.11.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.apis:google-api-services-storage:v1-rev20200430-1.30.9\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.code.gson:gson:2.8.6\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.cloud:google-cloud-core:1.93.6\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.cloud:google-cloud-core-http:1.93.6\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.http-client:google-http-client-appengine:1.35.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.api:gax-httpjson:0.74.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.api:gax:1.57.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.api.grpc:proto-google-iam-v1:0.13.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.protobuf:protobuf-java:3.12.2\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.protobuf:protobuf-java-util:3.12.2\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: org.threeten:threetenbp:1.4.4\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.cloud:google-cloud-firestore:1.35.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.cloud:google-cloud-core-grpc:1.93.6\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: io.grpc:grpc-core:1.30.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" scope=\"RUNTIME\" name=\"Maven: com.google.android:annotations:4.1.1.4\" level=\"project\" />\r\n    <orderEntry type=\"library\" scope=\"RUNTIME\" name=\"Maven: io.perfmark:perfmark-api:0.19.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: commons-logging:commons-logging:1.2\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: commons-codec:commons-codec:1.11\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.api.grpc:proto-google-cloud-firestore-admin-v1:1.35.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.api.grpc:proto-google-cloud-firestore-v1:1.35.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.api.grpc:proto-google-cloud-firestore-v1beta1:0.88.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: io.opencensus:opencensus-contrib-grpc-util:0.24.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: io.grpc:grpc-protobuf:1.30.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: io.grpc:grpc-protobuf-lite:1.30.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" scope=\"RUNTIME\" name=\"Maven: org.codehaus.mojo:animal-sniffer-annotations:1.18\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.api:gax-grpc:1.57.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: io.grpc:grpc-auth:1.30.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: io.grpc:grpc-netty-shaded:1.30.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: io.grpc:grpc-alts:1.30.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: io.grpc:grpc-grpclb:1.30.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: org.apache.commons:commons-lang3:3.5\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: org.conscrypt:conscrypt-openjdk-uber:2.2.1\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: io.grpc:grpc-stub:1.30.0\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.guava:guava:29.0-android\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: org.slf4j:slf4j-api:1.7.25\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: io.netty:netty-codec-http:4.1.50.Final\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: io.netty:netty-common:4.1.50.Final\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: io.netty:netty-buffer:4.1.50.Final\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: io.netty:netty-codec:4.1.50.Final\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: io.netty:netty-handler:4.1.50.Final\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: io.netty:netty-resolver:4.1.50.Final\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: io.netty:netty-transport:4.1.50.Final\" level=\"project\" />\r\n    <orderEntry type=\"library\" name=\"Maven: com.google.oauth-client:google-oauth-client:1.30.4\" level=\"project\" />\r\n  </component>\r\n</module>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Yolopoly/Yolopoly.iml	(revision ee870a899aa6a5c743fefffaae1e6a85b929dab2)
+++ Yolopoly/Yolopoly.iml	(date 1608396818028)
@@ -15,71 +15,7 @@
     <orderEntry type="library" name="Maven: org.openjfx:javafx-graphics:mac:15.0.1" level="project" />
     <orderEntry type="library" name="Maven: org.openjfx:javafx-base:mac:15.0.1" level="project" />
     <orderEntry type="library" name="Maven: org.openjfx:javafx-fxml:mac:15" level="project" />
-    <orderEntry type="library" name="Maven: com.google.firebase:firebase-admin:7.1.0" level="project" />
-    <orderEntry type="library" name="Maven: com.google.api-client:google-api-client:1.30.10" level="project" />
-    <orderEntry type="library" name="Maven: com.google.http-client:google-http-client-jackson2:1.36.0" level="project" />
-    <orderEntry type="library" name="Maven: com.google.api-client:google-api-client-gson:1.30.10" level="project" />
-    <orderEntry type="library" name="Maven: com.google.http-client:google-http-client-gson:1.36.0" level="project" />
-    <orderEntry type="library" name="Maven: com.google.http-client:google-http-client:1.35.0" level="project" />
-    <orderEntry type="library" name="Maven: org.apache.httpcomponents:httpclient:4.5.12" level="project" />
-    <orderEntry type="library" name="Maven: org.apache.httpcomponents:httpcore:4.4.13" level="project" />
-    <orderEntry type="library" name="Maven: com.google.j2objc:j2objc-annotations:1.3" level="project" />
-    <orderEntry type="library" name="Maven: io.opencensus:opencensus-api:0.24.0" level="project" />
-    <orderEntry type="library" name="Maven: io.opencensus:opencensus-contrib-http-util:0.24.0" level="project" />
-    <orderEntry type="library" name="Maven: com.google.api:api-common:1.9.2" level="project" />
-    <orderEntry type="library" name="Maven: javax.annotation:javax.annotation-api:1.3.2" level="project" />
-    <orderEntry type="library" name="Maven: com.google.auto.value:auto-value-annotations:1.7.2" level="project" />
-    <orderEntry type="library" name="Maven: com.google.auth:google-auth-library-oauth2-http:0.20.0" level="project" />
-    <orderEntry type="library" name="Maven: com.google.auth:google-auth-library-credentials:0.20.0" level="project" />
-    <orderEntry type="library" name="Maven: com.google.cloud:google-cloud-storage:1.110.0" level="project" />
-    <orderEntry type="library" name="Maven: com.google.guava:failureaccess:1.0.1" level="project" />
-    <orderEntry type="library" name="Maven: com.google.guava:listenablefuture:9999.0-empty-to-avoid-conflict-with-guava" level="project" />
-    <orderEntry type="library" name="Maven: org.checkerframework:checker-compat-qual:2.5.5" level="project" />
-    <orderEntry type="library" name="Maven: com.google.errorprone:error_prone_annotations:2.3.4" level="project" />
-    <orderEntry type="library" name="Maven: com.fasterxml.jackson.core:jackson-core:2.11.0" level="project" />
-    <orderEntry type="library" name="Maven: com.google.apis:google-api-services-storage:v1-rev20200430-1.30.9" level="project" />
-    <orderEntry type="library" name="Maven: com.google.code.gson:gson:2.8.6" level="project" />
-    <orderEntry type="library" name="Maven: com.google.cloud:google-cloud-core:1.93.6" level="project" />
-    <orderEntry type="library" name="Maven: com.google.cloud:google-cloud-core-http:1.93.6" level="project" />
-    <orderEntry type="library" name="Maven: com.google.http-client:google-http-client-appengine:1.35.0" level="project" />
-    <orderEntry type="library" name="Maven: com.google.api:gax-httpjson:0.74.0" level="project" />
-    <orderEntry type="library" name="Maven: com.google.api:gax:1.57.0" level="project" />
-    <orderEntry type="library" name="Maven: com.google.api.grpc:proto-google-iam-v1:0.13.0" level="project" />
-    <orderEntry type="library" name="Maven: com.google.protobuf:protobuf-java:3.12.2" level="project" />
-    <orderEntry type="library" name="Maven: com.google.protobuf:protobuf-java-util:3.12.2" level="project" />
-    <orderEntry type="library" name="Maven: org.threeten:threetenbp:1.4.4" level="project" />
-    <orderEntry type="library" name="Maven: com.google.cloud:google-cloud-firestore:1.35.0" level="project" />
-    <orderEntry type="library" name="Maven: com.google.cloud:google-cloud-core-grpc:1.93.6" level="project" />
-    <orderEntry type="library" name="Maven: io.grpc:grpc-core:1.30.0" level="project" />
-    <orderEntry type="library" scope="RUNTIME" name="Maven: com.google.android:annotations:4.1.1.4" level="project" />
-    <orderEntry type="library" scope="RUNTIME" name="Maven: io.perfmark:perfmark-api:0.19.0" level="project" />
-    <orderEntry type="library" name="Maven: commons-logging:commons-logging:1.2" level="project" />
-    <orderEntry type="library" name="Maven: commons-codec:commons-codec:1.11" level="project" />
-    <orderEntry type="library" name="Maven: com.google.api.grpc:proto-google-cloud-firestore-admin-v1:1.35.0" level="project" />
-    <orderEntry type="library" name="Maven: com.google.api.grpc:proto-google-cloud-firestore-v1:1.35.0" level="project" />
-    <orderEntry type="library" name="Maven: com.google.api.grpc:proto-google-cloud-firestore-v1beta1:0.88.0" level="project" />
-    <orderEntry type="library" name="Maven: io.opencensus:opencensus-contrib-grpc-util:0.24.0" level="project" />
-    <orderEntry type="library" name="Maven: io.grpc:grpc-protobuf:1.30.0" level="project" />
-    <orderEntry type="library" name="Maven: io.grpc:grpc-protobuf-lite:1.30.0" level="project" />
-    <orderEntry type="library" scope="RUNTIME" name="Maven: org.codehaus.mojo:animal-sniffer-annotations:1.18" level="project" />
-    <orderEntry type="library" name="Maven: com.google.api:gax-grpc:1.57.0" level="project" />
-    <orderEntry type="library" name="Maven: io.grpc:grpc-auth:1.30.0" level="project" />
-    <orderEntry type="library" name="Maven: io.grpc:grpc-netty-shaded:1.30.0" level="project" />
-    <orderEntry type="library" name="Maven: io.grpc:grpc-alts:1.30.0" level="project" />
-    <orderEntry type="library" name="Maven: io.grpc:grpc-grpclb:1.30.0" level="project" />
-    <orderEntry type="library" name="Maven: org.apache.commons:commons-lang3:3.5" level="project" />
-    <orderEntry type="library" name="Maven: org.conscrypt:conscrypt-openjdk-uber:2.2.1" level="project" />
-    <orderEntry type="library" name="Maven: io.grpc:grpc-stub:1.30.0" level="project" />
-    <orderEntry type="library" name="Maven: com.google.guava:guava:29.0-android" level="project" />
-    <orderEntry type="library" name="Maven: org.slf4j:slf4j-api:1.7.25" level="project" />
-    <orderEntry type="library" name="Maven: io.netty:netty-codec-http:4.1.50.Final" level="project" />
-    <orderEntry type="library" name="Maven: io.netty:netty-common:4.1.50.Final" level="project" />
-    <orderEntry type="library" name="Maven: io.netty:netty-buffer:4.1.50.Final" level="project" />
-    <orderEntry type="library" name="Maven: io.netty:netty-codec:4.1.50.Final" level="project" />
-    <orderEntry type="library" name="Maven: io.netty:netty-handler:4.1.50.Final" level="project" />
-    <orderEntry type="library" name="Maven: io.netty:netty-resolver:4.1.50.Final" level="project" />
-    <orderEntry type="library" name="Maven: io.netty:netty-transport:4.1.50.Final" level="project" />
-    <orderEntry type="library" name="Maven: com.google.oauth-client:google-oauth-client:1.30.4" level="project" />
+    <orderEntry type="library" name="Maven: org.openjfx:javafx-media:mac:15" level="project" />
     <orderEntry type="library" name="Maven: org.openjfx:javafx-controls:15.0.1" level="project" />
     <orderEntry type="library" name="Maven: org.openjfx:javafx-controls:win:15.0.1" level="project" />
     <orderEntry type="library" name="Maven: org.openjfx:javafx-graphics:15.0.1" level="project" />
